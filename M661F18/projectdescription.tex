\documentclass[12pt]{amsart}
%prepared in AMSLaTeX, under LaTeX2e
\addtolength{\oddsidemargin}{-.5in}
\addtolength{\evensidemargin}{-.5in}
\addtolength{\topmargin}{-0.5in}
\addtolength{\textwidth}{1.1in}
\addtolength{\textheight}{1.0in}
\newcommand{\normalspacing}{\renewcommand{\baselinestretch}{1.05}
        \tiny\normalsize}

\newtheorem*{thm}{Theorem}
\newtheorem*{defn}{Definition}
\newtheorem*{example}{Example}
\newtheorem*{problem}{Problem}
\newtheorem*{remark}{Remark}

\usepackage{amssymb,fancyvrb,xspace}
\usepackage{palatino}

\usepackage[final]{graphicx}

\usepackage{tikz}
\usetikzlibrary{shapes,arrows,arrows.meta}


\usepackage[pdftex, colorlinks=true, plainpages=false, linkcolor=black, citecolor=red, urlcolor=red]{hyperref}

% macros
\newcommand{\ba}{\mathbf{a}}
\newcommand{\bb}{\mathbf{b}}
\newcommand{\bn}{\mathbf{n}}
\newcommand{\br}{\mathbf{r}}
\newcommand{\bu}{\mathbf{u}}
\newcommand{\bv}{\mathbf{v}}
\newcommand{\bx}{\mathbf{x}}
\newcommand{\by}{\mathbf{y}}

\newcommand{\bT}{\mathbf{T}}

\newcommand{\CC}{\mathbb{C}}
\newcommand{\Div}{\nabla\cdot}
\newcommand{\eps}{\epsilon}
\newcommand{\grad}{\nabla}
\newcommand{\ZZ}{\mathbb{Z}}
\newcommand{\ip}[2]{\ensuremath{\left<#1,#2\right>}}
\newcommand{\lam}{\lambda}
\newcommand{\lap}{\triangle}
\newcommand{\RR}{\mathbb{R}}

\newcommand{\prob}[1]{\bigskip\noindent\large\textbf{#1}.\,\normalsize }
\newcommand{\ppart}[1]{\textbf{(#1)}\,\, }
\newcommand{\epart}[1]{\medskip\noindent\textbf{(#1)}\,\, }

\newcommand{\pts}[1]{\scriptsize [#1 points] \normalsize}

\newcommand{\Matlab}{\textsc{Matlab}\xspace}
\newcommand{\Python}{\textsc{Python}\xspace}
\newcommand{\Julia}{\textsc{Julia}\xspace}


\begin{document}
\scriptsize \phantom{bob} \vspace{-0.3in}
\noindent Math 661 Optimization \, (Bueler) \hfill  October 29, 2018
\normalsize\bigskip
\normalspacing

\Large\centerline{\textbf{About your project}}
\normalsize

\bigskip\medskip
\thispagestyle{empty}
\normalspacing

\subsection*{Goal}  The goal of the Math 661 project is for you to become more familiar with certain optimization problems and algorithms than is possible with the brief coverage that is typical of the rest of the course.

\subsection*{Expectations}  Your project may be application-driven (\emph{choose the problem(s) first}) or algorithm-driven (\emph{choose the algorithm(s) first})---see page 3---but all projects must include a specific optimization problem and a specific optimization algorithm.  That is, you will implement at least one algorithm, i.e.~in \Matlab/\Python/ \Julia/etc., and apply your code to at least one example problem.

Both numerical computation and mathematical analysis are required.  For the latter you will analyze the problem(s) and algorithm(s) using theory from the textbook\footnote{Griva, Nash, and Sofer, \emph{Linear and Nonlinear Optimization}, 2nd ed., SIAM Press 2009.} and/or from other references.  Once your code is running you should provide some empirical (numerical experimentation) evidence regarding the error and/or performance of your algorithm(s).  Analysis is important because it shows you have absorbed ideas from the course, and because it distinquishes between algorithms.  Numerical evidence is important because it confirms that you understood the algorithm well enough to implement it correctly.

Your problem(s) must be in the following form:
\begin{equation}
\min_{x\in \RR^n} f(x) \quad \text{subject to} \quad \begin{matrix}
                                                      g_i(x) = 0, & i \in \mathcal{E}, \\
                                                      g_i(x) \ge 0, & i \in \mathcal{I},
                                                      \end{matrix}  \label{genform}
\end{equation}
though of course you may replace $\min$ with $\max$.  If your project is algorithm-driven then you must identify which such problems are solved by your algorithms(s).

Form \eqref{genform} describes a very large class of problems, but note your problem(s) must be finite-dimensional ($\RR^n$), though they may arise from an infinite-dimensional source.  The problem(s) must be well-enough understood to allow you to both precisely identify the objective function $f(x)$ and precisely identify a feasible set $S$ defined by finitely-many constraints $g_i(x)$.  It is o.k.~if there are no constraints.  


\subsection*{Due dates}  There are two due dates for the project:

\medskip
\begin{itemize}
\item[\underline{I = Proposal:}]  \textbf{Part I is due Friday 9 November at the start of class.}\footnote{This is a change from the date on the syllabus.}  There are no format requirements for this part except that it \textbf{can be at most two pages}.

The content of the proposal should be to say precisely what problem(s) or algorithm(s) you want to look at.  Several quality references are \emph{expected}; online references are o.k.\footnote{However, I find that many informal online documents are of low quality.}  Make specific references to our textbook when that is appropriate.

You should spend at most (say) 6 hours on this.  However, spending at least a few hours on thinking and research at this stage can be very effective.  Ideally you will talk about and play with ideas as you get a clearer idea of what to write in your proposal.

It would be good to use a version control system if you know how.  In any case, your efforts should grow in an organized manner and not get lost.

\medskip
\item[\underline{II = Project:}]  \textbf{On Tuesday 11 December at 5pm you will submit the complete project.}

It should have the format and section headings as shown on page 4 below.  This format corresponds to a \LaTeX\xspace document template already posted online, but of course you do not have to use \LaTeX:

\centerline{\href{http://bueler.github.io/M661F18/index.html}{\texttt{bueler.github.io/M661F18/blankproject.tex}}}

The total length \textbf{must be 20 pages or less}; I will not accept longer projects.  The total time spent on the whole project should be at most 25 hours.
\end{itemize}


\subsection*{Choosing a topic}  One of my jobs will be to help you choose problem(s) and algorithm(s) so that your project has reasonable difficulty.  I will likely advise you not to bite off too much!  It is very easy to get lost in the application, the algorithmic details, or in difficulties with codes or analysis.

You may not choose a topic which has been, or will be, adequately covered in the course.  For example, though the basic simplex method is not a good topic, implementations of the simplex method which respect sparsity are (Chapter 7).  Similarly, the classical Newton method is not a good subject but investigating quasi-Newton methods, line search methods, or trust region methods may be quite good choices (Chapters 11,12).  Your proposal allows me to give good feedback on this, perhaps a gentle nudge in the direction of a nice variation to study.

Here are three approaches to choosing a topic if you don't already have one:

\subsubsection*{Approach 1: Inspiration from Wikipedia page on mathematical optimization}  See the ``Applications,'' ``Major subfields,'' and ``Computational \dots techniques'' sections of

   \centerline{\href{https://en.wikipedia.org/wiki/Mathematical_optimization}{\texttt{en.wikipedia.org/wiki/Mathematical\_optimization}}}

\subsubsection*{Approach 2: Investigate skipped material from the textbook}  Consider choosing a section(s) that you find interesting and which we did not cover.  I am not really recommending just choosing a section at random; the Wikipedia page above is a better if you are starting from scratch.

\subsubsection*{Approach 3: Talk to your advisor and/or do something related to your thesis}  You can talk to me, but it will take a while for me to know what you are interested in.  It would be better to talk to your thesis advisor (if you have one).  It is reasonable to ask ``are there optimization problems related to my expected thesis''?  Broadly-speaking these might relate to optimal design or parameter fitting, or to algorithms which arise in your field of interest.  There may be a paper to read about optimization in your field.


\newpage
\subsection*{Structure of the project}  Here is a rough flow-chart.

\bigskip

% Define block styles
\tikzstyle{decision} = [diamond, draw,
    text width=4.5em, text centered, node distance=3cm, inner sep=0pt]
\tikzstyle{block} = [rectangle, draw,
    text width=9em, text badly centered, rounded corners, minimum height=4em]
\tikzstyle{bigblock} = [rectangle, draw,
    text width=24em, text badly centered, rounded corners, minimum height=4em]
\tikzstyle{line} = [draw, -{Latex[length=3mm, width=2mm]}]

\begin{center}
\begin{tikzpicture}[node distance=2.4cm, auto, font=\small]
    % decide
    \node [decision] (decide) {is your project driven by?};

    % algorithm sequence
    \node [block, below left of=decide, node distance=4cm] (introalg) {introduce algorithm(s)};
    \path [line] (decide.west) -- node [near start, left] {algorithm} (introalg.north);
    \node [block, below of=introalg] (algpseudo) {give pseudocode(s)};
    \path [line] (introalg) -- (algpseudo);
    \node [block, below of=algpseudo] (algexamples) {propose at least one example problem for testing};
    \path [line] (algpseudo) -- (algexamples);

    % application sequence
    \node [block, below right of=decide, node distance=4cm] (introapp) {introduce application(s)};
    \path [line] (decide.east) -- node [near start] {application} (introapp.north);
    \node [block, below of=introapp] (appexamples) {describe at least one example problem};
    \path [line] (introapp) -- (appexamples);
    \node [block, below of=appexamples] (appcompare) {describe at least one algorithm; give pseudocodes};
    \path [line] (appexamples) -- (appcompare);

    % merge and continue
    \node [block, below of=decide, node distance=10.5cm] (implement) {implement algorithms in \Matlab/\dots};
    \path [line] (algexamples) -- (implement);
    \path [line] (appcompare) -- (implement);
    \node [block, below of=implement] (results) {demonstrate runs on example(s); show results};
    \path [line] (implement) -- (results);
    \node [bigblock, below of=results] (analysis) {analysis: \begin{itemize}
       \item convergence: e.g.~state theorems; compare rates
       \item performance: e.g.~count operations; show timing
       \end{itemize}     };
    \path [line] (results) -- (analysis);
    \node [block, below of=analysis] (conclude) {what you would do next? conclude};
    \path [line] (analysis) -- (conclude);
\end{tikzpicture}
\end{center}


\end{document}
